// Copyright (c) Tailscale Inc & AUTHORS
// SPDX-License-Identifier: BSD-3-Clause

//go:build !plan9

package kube

import (
	"fmt"
	"net/netip"

	"github.com/gaissmai/bart"
	"tailscale.com/tailcfg"
)

// TODO: move all this to ./kube

const (
	Alpha1Version = "v1alpha1"

	DNSRecordsCMName = "dnsrecords"
	DNSRecordsCMKey  = "records.json"
)

type Records struct {
	// Version is the version of this Records configuration. Version is
	// written by the operator, i.e when it first populates the Records.
	// k8s-nameserver must verify that it knows how to parse a given
	// version.
	Version string `json:"version"`

	// This will go- this will only contain ingress/egress destinations, not what
	// service IPs this is assigned to.

	// IP4 contains a mapping of DNS names to IPv4 address(es).
	IP4 map[string][]string `json:"ip4"`
	// TODO: probably don't need this here
	AddrsToDomain *bart.Table[string] `json:"addrsToDomain"`
	// Probably should not be a string so that don't need to parse twice
	// TODO: remove from here
	DNSAddr string `json:"dnsAddr"`
}

// TailscaledConfigFileNameForCap returns a tailscaled config file name in
// format expected by containerboot for the given CapVer.
func TailscaledConfigFileNameForCap(cap tailcfg.CapabilityVersion) string {
	if cap < 95 {
		return "tailscaled"
	}
	return fmt.Sprintf("cap-%v.hujson", cap)
}

// CapVerFromFileName parses the capability version from a tailscaled
// config file name previously generated by TailscaledConfigFileNameForCap.
func CapVerFromFileName(name string) (tailcfg.CapabilityVersion, error) {
	if name == "tailscaled" {
		return 0, nil
	}
	var cap tailcfg.CapabilityVersion
	_, err := fmt.Sscanf(name, "cap-%d.hujson", &cap)
	return cap, err
}

type ProxyConfig struct {
	// Maybe we don't need to put this one here- it's just convenient for
	// the services reconciler to read it from here.
	ServicesCIDRRange netip.Prefix       `json:"serviceCIDR,omitempty"`
	Services          map[string]Service `json:"services,omitempty"`

	// For lookup convenience
	AddrsToDomain *bart.Table[string] `json:"addrsToDomain,omitempty"`
}

type Service struct {
	FQDN         string       `json:"fqdn,omitempty"`
	V4ServiceIPs []netip.Addr `json:"vService4ips"`
	Ingress      *Ingress     `json:"ingress"`
}

type Ingress struct {
	Type string `json:"type"` // tcp or http
	// type?
	V4Backends []netip.Addr `json:"v4Backends"`
}
